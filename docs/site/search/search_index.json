{
    "docs": [
        {
            "location": "/",
            "text": "KirchMig.jl\n\n\nKirchhoff migration is a method used in geophysics, nondestructive testing and other areas to obtain high-frequency representations of the impedance contrasts of a target medium. In geophysics, it is also known as the \ndiffraction stack\n, and in nondestructive testing as \ntotal focusing method\n (TFM).\n\n\nWhat this package is \nnot\n: This package is not focused in providing extensive traveltime computation methods, such as eikonal solvers, ray-tracers, etc. Many of these can be already found in software suits like \nMadagascar\n. I recommend the \nexcellent \nsfeikonal\n solver\n. In the future, I might incorporate \nsfeikonal\n and other Madagascar tools within the library. This package is also not, a priori, designed to be an advanced, true-amplitude migration tool with many bells and whistles, although it might mutate into that in the future. Of course I am more than happy to incorporate more advanced Kirchhoff migration (and demigration).\n\n\nWhat this package is: At the moment I am interested in providing a simple-to-use and simple-to-grasp Kirchhoff inversion toolset. I am interested in writing this with a linear mapping framework taking special care of providing forward and adjoint maps which respect the \ndot product test\n. In this way, the linear maps provided can be used in inversion methods, for example in so-called \nleast-squares migration\n.\n\n\n\n\nGet started\n\n\nOnce \nJulia 0.6.2\n is installed, open the REPL and run\n\n\nPkg.clone\n(\n\"https://github.com/cako/KirchMig.jl\"\n)\n\n\n\n\n\n\nA few examples are provided as scripts and Jupyter notebooks \nhere\n.",
            "title": "Home"
        },
        {
            "location": "/#kirchmigjl",
            "text": "Kirchhoff migration is a method used in geophysics, nondestructive testing and other areas to obtain high-frequency representations of the impedance contrasts of a target medium. In geophysics, it is also known as the  diffraction stack , and in nondestructive testing as  total focusing method  (TFM).  What this package is  not : This package is not focused in providing extensive traveltime computation methods, such as eikonal solvers, ray-tracers, etc. Many of these can be already found in software suits like  Madagascar . I recommend the  excellent  sfeikonal  solver . In the future, I might incorporate  sfeikonal  and other Madagascar tools within the library. This package is also not, a priori, designed to be an advanced, true-amplitude migration tool with many bells and whistles, although it might mutate into that in the future. Of course I am more than happy to incorporate more advanced Kirchhoff migration (and demigration).  What this package is: At the moment I am interested in providing a simple-to-use and simple-to-grasp Kirchhoff inversion toolset. I am interested in writing this with a linear mapping framework taking special care of providing forward and adjoint maps which respect the  dot product test . In this way, the linear maps provided can be used in inversion methods, for example in so-called  least-squares migration .",
            "title": "KirchMig.jl"
        },
        {
            "location": "/#get-started",
            "text": "Once  Julia 0.6.2  is installed, open the REPL and run  Pkg.clone ( \"https://github.com/cako/KirchMig.jl\" )   A few examples are provided as scripts and Jupyter notebooks  here .                          <!--`\u2013>",
            "title": "Get started"
        },
        {
            "location": "/examples/",
            "text": "Layer Cake\n\n\nThis notebook\n (or its associated \nscript\n) is a good starting point. It shows basic functionality of all steps of Kirchhoff inversion: traveltime computations, Kirchhoff mapping and inversion by conjugate gradients.\n\n\n\n\nLayer Cake: Regularization\n\n\nThis notebook\n (or its associated \nscript\n) has some more advanced functionality including regularing the inversion.",
            "title": "Examples"
        },
        {
            "location": "/examples/#layer-cake",
            "text": "This notebook  (or its associated  script ) is a good starting point. It shows basic functionality of all steps of Kirchhoff inversion: traveltime computations, Kirchhoff mapping and inversion by conjugate gradients.",
            "title": "Layer Cake"
        },
        {
            "location": "/examples/#layer-cake-regularization",
            "text": "This notebook  (or its associated  script ) has some more advanced functionality including regularing the inversion.",
            "title": "Layer Cake: Regularization"
        },
        {
            "location": "/function/",
            "text": "KirchMig.KirchMap\n\n\nKirchMig.DiffZMap\n\n\nKirchMig.LaplacianMap\n\n\nKirchMig.cg\n\n\nKirchMig.eikonal_const_vel",
            "title": "Function Index"
        },
        {
            "location": "/function/map/",
            "text": "Kirchhoff map\n\n\n#\n\n\nKirchMig.KirchMap\n \u2014 \nType\n.\n\n\nKirchMap{eltype(t)}(t, trav_r, [trav_s]; parallel_threaded_serial=\"serial\")\n\n\nConstruct a Kirchhoff LinearMap object, which can perform Kirchhoff modeling (or more accurately, demigration) as a forward operator and Kirchhoff migration as an adjoint operation.\n\n\nParameters\n\n\n\n\nt\n : \n(nt,)\n, \nAbstractVector{<:Real}\n\n\n\n\nContains time samples which correspond to the data domain. \nKirchMap(t, trav)*m\n will create data whose time axis is given by \nt\n. Its type defines the type of \nKirchMap\n.\n\n\n\n\ntrav_r\n : \n(nz, [nx, ny, ...], nr)\n, \nAbstractArray{<:Real, M}\n\n\n\n\nContains traveltimes between each model parameter and receiver location. The first \nM-1\n dimensions are model dimensions \n(z, x, y, ...)\n, and the last dimension corresponds to receivers.\n\n\n\n\ntrav_s\n : \n(nz, [nx, ny, ...], ns)\n, \nAbstractArray{<:Real, M}\n, optional\n\n\n\n\nLike \ntrav_r\n but for sources. If omitted, defaults to \ntrav_r\n, i.e., sources and receivers are assumed colocated.\n\n\n\n\nparallel_threaded_serial\n : \nString\n\n\n\n\nDefines which Kirchhoff methods to use. Can be the default, \nparallel\n, which uses Julia's distributed computing to parallelize over receivers; \nthreaded\n which uses multi-threading to parallelize over receivers; or \nserial\n. It is highly recommended to not use the \nserial\n version, even when only using a single worker or thread.\n\n\nUsage\n\n\n\n\nForward map\n\n\n\n\nThe forward map \nL\n multiplies a model vector of size \nnz \u00d7 nx \u00d7 ny \u00d7 ...\n to create a data vector of size \nnr \u00d7 ns \u00d7 nt\n.\n\n\n\n\nAdjoint map\n\n\n\n\nThe adjoint map \nL'\n multiplies a data vector of size \nnr \u00d7 ns \u00d7 nt\n to create a model vector of size \nnz \u00d7 nx \u00d7 ny \u00d7 ...\n\n\nDescription\n\n\nThe forward map computes the discretized version of the following operation\n\n\n\n\n\nd(r, s, t) = \\int m(x)\\,\\delta(t - \\tau_{sx} - \\tau_{xr})\\,\\mathrm{d}x.\n\n\n\n\n\nand the adjoint map computes\n\n\n\n\n\nm(x) = \\int d(t, r, s)\\,\\delta(t - \\tau_{sx} - \\tau_{xr})\\,\\mathrm{d}r\\,\\mathrm{d}s\\,\\mathrm{d}t.\n\n\n\n\n\nIn both computations, the differential elements (which only affect amplitude) are neglected.\n\n\nsource",
            "title": "Map"
        },
        {
            "location": "/function/map/#kirchhoff-map",
            "text": "#  KirchMig.KirchMap  \u2014  Type .  KirchMap{eltype(t)}(t, trav_r, [trav_s]; parallel_threaded_serial=\"serial\")  Construct a Kirchhoff LinearMap object, which can perform Kirchhoff modeling (or more accurately, demigration) as a forward operator and Kirchhoff migration as an adjoint operation.  Parameters   t  :  (nt,) ,  AbstractVector{<:Real}   Contains time samples which correspond to the data domain.  KirchMap(t, trav)*m  will create data whose time axis is given by  t . Its type defines the type of  KirchMap .   trav_r  :  (nz, [nx, ny, ...], nr) ,  AbstractArray{<:Real, M}   Contains traveltimes between each model parameter and receiver location. The first  M-1  dimensions are model dimensions  (z, x, y, ...) , and the last dimension corresponds to receivers.   trav_s  :  (nz, [nx, ny, ...], ns) ,  AbstractArray{<:Real, M} , optional   Like  trav_r  but for sources. If omitted, defaults to  trav_r , i.e., sources and receivers are assumed colocated.   parallel_threaded_serial  :  String   Defines which Kirchhoff methods to use. Can be the default,  parallel , which uses Julia's distributed computing to parallelize over receivers;  threaded  which uses multi-threading to parallelize over receivers; or  serial . It is highly recommended to not use the  serial  version, even when only using a single worker or thread.  Usage   Forward map   The forward map  L  multiplies a model vector of size  nz \u00d7 nx \u00d7 ny \u00d7 ...  to create a data vector of size  nr \u00d7 ns \u00d7 nt .   Adjoint map   The adjoint map  L'  multiplies a data vector of size  nr \u00d7 ns \u00d7 nt  to create a model vector of size  nz \u00d7 nx \u00d7 ny \u00d7 ...  Description  The forward map computes the discretized version of the following operation   \nd(r, s, t) = \\int m(x)\\,\\delta(t - \\tau_{sx} - \\tau_{xr})\\,\\mathrm{d}x.   and the adjoint map computes   \nm(x) = \\int d(t, r, s)\\,\\delta(t - \\tau_{sx} - \\tau_{xr})\\,\\mathrm{d}r\\,\\mathrm{d}s\\,\\mathrm{d}t.   In both computations, the differential elements (which only affect amplitude) are neglected.  source",
            "title": "Kirchhoff map"
        },
        {
            "location": "/function/eikonal/",
            "text": "Traveltime computations\n\n\n#\n\n\nKirchMig.eikonal_const_vel\n \u2014 \nFunction\n.\n\n\neikonal_const_vel(src, z, x, [y, ] velocity)\n\n\nCompute traveltime tables between \nsrc\n locations and subsurface model locations given by \nz\n, \nx\n, and optionally \ny\n. It assumes \nvelocity\n is constant.\n\n\nParameters\n\n\n\n\nsrc\n : \n(ns, n)\n, \nAbstractMatrix{<:Real}\n\n\n\n\nThe \n(z_s, x_s [, x_y])\n coordinates for every source. In 2D, \nn = 2\n and in 3D \nn = 3\n.\n\n\n\n\nz\n : \n(nz,)\n, \nAbstractVector{<:Real}\n\n\n\n\nModel depth \nz\n coordinates.\n\n\n\n\nx\n : \n(nx,)\n, \nAbstractVector{<:Real}\n\n\n\n\nModel horizontal \nx\n coordinates.\n\n\n\n\ny\n : \n(ny,)\n, \nAbstractVector{<:Real}\n, optional\n\n\n\n\nModel horizontal \ny\n coordinates.\n\n\n\n\nvelocity\n : \nReal\n\n\n\n\nWave speed\n\n\nReturns\n\n\n\n\ntrav\n : \n(nz, nx, [ny, ] ns)\n, \nAbstractArray{<:Real, M}\n\n\n\n\nTraveltime between each src and locations given by \nz\n, \nx\n and optionally \ny\n:\n\n\n\n\n\nt(z, x, y, s) = \\frac{\\sqrt{(z-s_z)^2 + (x-s_x)^2 + (y-s_y)^2}}{v}\n\n\n\n\n\nsource",
            "title": "Eikonal"
        },
        {
            "location": "/function/eikonal/#traveltime-computations",
            "text": "#  KirchMig.eikonal_const_vel  \u2014  Function .  eikonal_const_vel(src, z, x, [y, ] velocity)  Compute traveltime tables between  src  locations and subsurface model locations given by  z ,  x , and optionally  y . It assumes  velocity  is constant.  Parameters   src  :  (ns, n) ,  AbstractMatrix{<:Real}   The  (z_s, x_s [, x_y])  coordinates for every source. In 2D,  n = 2  and in 3D  n = 3 .   z  :  (nz,) ,  AbstractVector{<:Real}   Model depth  z  coordinates.   x  :  (nx,) ,  AbstractVector{<:Real}   Model horizontal  x  coordinates.   y  :  (ny,) ,  AbstractVector{<:Real} , optional   Model horizontal  y  coordinates.   velocity  :  Real   Wave speed  Returns   trav  :  (nz, nx, [ny, ] ns) ,  AbstractArray{<:Real, M}   Traveltime between each src and locations given by  z ,  x  and optionally  y :   \nt(z, x, y, s) = \\frac{\\sqrt{(z-s_z)^2 + (x-s_x)^2 + (y-s_y)^2}}{v}   source",
            "title": "Traveltime computations"
        },
        {
            "location": "/function/optimization/",
            "text": "A \nsimple\n conjugate gradients solver is provided, but using \nIterativeSolvers.jl\n is highly recommended.\n\n\n#\n\n\nKirchMig.cg\n \u2014 \nFunction\n.\n\n\ncg(A, b [, x0];  maxiter=10, tol=1e-3, log=false) -> x [, history_x, history_r]\n\n\nSolve the system \nAx = b\n of a symmetric, positive definite linear map given by \nA\n using the conjugate gradients method.\n\n\nParameters\n\n\n\n\nA\n\n\n\n\nLinear map, which must have two methods defined: multiplication by \nAbstractVector\n and transpose multiplication by \nAbstractVector\n.\n\n\n\n\nb\n : \nAbstractVector\n\n\n\n\nRHS of equation \nAx = b\n.\n\n\n\n\nx0\n : \nAbstractVector\n\n\n\n\nStarting solution.\n\n\n\n\nmaxiter\n : Int, optional\n\n\n\n\nMaximum number of iterations. Defaults to 10.\n\n\n\n\ntol\n : Real, optional\n\n\n\n\nStopping criterion tolerance. Stops if the square root of the ration between the previous and current residuals is smaller than \ntol\n. Defaults to 1e-3.\n\n\n\n\nlog\n : Bool, optional\n\n\n\n\nIf \ntrue\n, returns also model and residuals at each iterations.\n\n\nsource",
            "title": "Optimization"
        },
        {
            "location": "/function/regularization/",
            "text": "#\n\n\nKirchMig.LaplacianMap\n \u2014 \nFunction\n.\n\n\nLaplacianMap([T,] n...) -> \u0394\n\n\nConstruct a discretized Laplacian operator \u0394 which will act on an \nAbstractVector\n.\n\n\nParameters\n\n\n\n\nT\n : \nType\n, optional\n\n\n\n\nType\n of argument of \n\u0394\n. Defaults to \nFloat64\n.\n\n\n\n\nn...\n\n\n\n\nSequence of spatial dimensions of \n\u0394\n.\n\n\nUsage\n\n\n\n\nForward map and Adjoint maps\n\n\n\n\nThe forward map \n\u0394\n multiplies a model vector of size \nnz \u00d7 nx \u00d7 ny \u00d7 ...\n its second order derivative. It is symmetric.\n\n\nDescription\n\n\nThe forward and adjoint maps computes the following operation\n\n\n\n\n\n\u0394x = \\sum_{i} \u03b4_i x\n\n\n\n\n\nwhere \n\n\n\n\n\n\u03b4_l x_{i,j,k,...} = - x_{...,l+1,...} + 2x_{...,l,...} - x_{...,l-1,...}\n\n\n\n\n\nsource\n\n\n#\n\n\nKirchMig.DiffZMap\n \u2014 \nFunction\n.\n\n\nDiffZMap([T,] n...) -> \u03b4z\n\n\nConstruct a discretized z-derivative operator \u03b4z which will act on an \nAbstractVector\n.\n\n\nParameters\n\n\n\n\nT\n : \nType\n, optional\n\n\n\n\nType\n of argument of \n\u03b4z\n. Defaults to \nFloat64\n.\n\n\n\n\nn...\n\n\n\n\nSequence of spatial dimensions of \n\u03b4z\n.\n\n\nUsage\n\n\n\n\nForward map and Adjoint maps\n\n\n\n\nThe forward map \n\u03b4z\n multiplies a model vector of size \nnz \u00d7 nx \u00d7 ny \u00d7 ...\n its first order z-derivative. The adjoint map is minus the forward map.\n\n\nDescription\n\n\nThe forward map computes the following operation\n\n\n\n\n\n\u03b4z x_{i,j,k,...} = (x_{l+1,...} - x_{l-1,...})/2\n\n\n\n\n\nand the adjoint map computes \n-\u03b4z\n.\n\n\nsource",
            "title": "Regularization"
        },
        {
            "location": "/LICENSE/",
            "text": "The KirchMig.jl package is licensed under the MIT \"Expat\" License:\n\n\n\n\nCopyright (c) 2018: Carlos Alberto da Costa Filho.\n\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n\n\nThe above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.",
            "title": "License"
        }
    ]
}