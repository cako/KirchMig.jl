var documenterSearchIndex = {"docs":
[{"location":"index.html#","page":"Home","title":"Home","text":"<p align=\"center\"> <img src=\"https://s3.eu-west-2.amazonaws.com/cdacosta-londonbucket/github/forward-diagram.png?raw=true\" width=400px alt=\"Forward map diagram\"/> </p>","category":"page"},{"location":"index.html#KirchMig.jl-1","page":"Home","title":"KirchMig.jl","text":"","category":"section"},{"location":"index.html#","page":"Home","title":"Home","text":"Kirchhoff migration is a method used in geophysics, nondestructive testing and other areas to obtain high-frequency representations of the impedance contrasts of a target medium. In geophysics, it is also known as the diffraction stack, and in nondestructive testing as total focusing method (TFM).","category":"page"},{"location":"index.html#","page":"Home","title":"Home","text":"What this package is not: This package is not focused in providing extensive traveltime computation methods, such as eikonal solvers, ray-tracers, etc. Many of these can be already found in software suits like Madagascar. I recommend the excellent sfeikonal solver. In the future, I might incorporate sfeikonal and other Madagascar tools within the library. This package is also not, a priori, designed to be an advanced, true-amplitude migration tool with many bells and whistles, although it might mutate into that in the future. Of course I am more than happy to incorporate more advanced Kirchhoff migration (and demigration).","category":"page"},{"location":"index.html#","page":"Home","title":"Home","text":"What this package is: At the moment I am interested in providing a simple-to-use and simple-to-grasp Kirchhoff inversion toolset. I am interested in writing this with a linear mapping framework taking special care of providing forward and adjoint maps which respect the dot product test. In this way, the linear maps provided can be used in inversion methods, for example in so-called least-squares migration.","category":"page"},{"location":"index.html#Get-started-1","page":"Home","title":"Get started","text":"","category":"section"},{"location":"index.html#","page":"Home","title":"Home","text":"Once Julia 1.0 is installed, open the REPL and run","category":"page"},{"location":"index.html#","page":"Home","title":"Home","text":"using Pkg\nPkg.add(PackageSpec(url=\"https://github.com/cako/KirchMig.jl.git\"))","category":"page"},{"location":"index.html#","page":"Home","title":"Home","text":"A few examples are provided as scripts and Jupyter notebooks here.","category":"page"},{"location":"examples.html#Layer-Cake-1","page":"Examples","title":"Layer Cake","text":"","category":"section"},{"location":"examples.html#","page":"Examples","title":"Examples","text":"Basic functionality of all steps of Kirchhoff inversion such as traveltime computations, Kirchhoff mapping and inversion by conjugate gradients.","category":"page"},{"location":"examples.html#","page":"Examples","title":"Examples","text":"[notebook, script]","category":"page"},{"location":"examples.html#Layer-Cake-Regularization-Part-1-1","page":"Examples","title":"Layer Cake Regularization Part 1","text":"","category":"section"},{"location":"examples.html#","page":"Examples","title":"Examples","text":"Has some more advanced functionality including regularized noisy inversion using IterativeSolvers.jl.","category":"page"},{"location":"examples.html#","page":"Examples","title":"Examples","text":"[notebook, script]","category":"page"},{"location":"examples.html#Layer-Cake-Regularization-Part-2-1","page":"Examples","title":"Layer Cake Regularization Part 2","text":"","category":"section"},{"location":"examples.html#","page":"Examples","title":"Examples","text":"Regularization by cost function using Optim.jl. Has an in-depth example of Total Variation (TV) regularization.","category":"page"},{"location":"examples.html#","page":"Examples","title":"Examples","text":"[notebook, script]","category":"page"},{"location":"function/index.html#","page":"Index","title":"Index","text":"","category":"page"},{"location":"function/map.html#","page":"Kirchhoff Map","title":"Kirchhoff Map","text":"KirchMap","category":"page"},{"location":"function/map.html#KirchMig.KirchMap","page":"Kirchhoff Map","title":"KirchMig.KirchMap","text":"KirchMap{eltype(t)}(t, trav_r, [trav_s]; parallel_threaded_serial=\"serial\")\n\nConstruct a Kirchhoff LinearMap object, which can perform Kirchhoff modeling (or more accurately, demigration) as a forward operator and Kirchhoff migration as an adjoint operation.\n\nParameters\n\nt : (nt,), AbstractVector{<:Real}\n\nContains time samples which correspond to the data domain. KirchMap(t, trav)*m will create data whose time axis is given by t. Its type defines the type of KirchMap.\n\ntrav_r : (nz, [nx, ny, ...], nr), AbstractArray{<:Real, M}\n\nContains traveltimes between each model parameter and receiver location. The first M-1 dimensions are model dimensions (z, x, y, ...), and the last dimension corresponds to receivers.\n\ntrav_s : (nz, [nx, ny, ...], ns), AbstractArray{<:Real, M}, optional\n\nLike trav_r but for sources. If omitted, defaults to trav_r, i.e., sources and receivers are assumed colocated.\n\nparallel_threaded_serial : String\n\nDefines which Kirchhoff methods to use. Can be the default, parallel, which uses Julia's distributed computing to parallelize over receivers; threaded which uses multi-threading to parallelize over receivers; or serial. It is highly recommended to not use the serial version, even when only using a single worker or thread.\n\nUsage\n\nForward map\n\nThe forward map L multiplies a model vector of size nz × nx × ny × ... to create a data vector of size nr × ns × nt.\n\nAdjoint map\n\nThe adjoint map L' multiplies a data vector of size nr × ns × nt to create a model vector of size nz × nx × ny × ...\n\nDescription\n\nThe forward map computes the discretized version of the following operation\n\nd(r s t) = int m(x)delta(t - tau_sx - tau_xr)mathrmdx\n\nand the adjoint map computes\n\nm(x) = int d(t r s)delta(t - tau_sx - tau_xr)mathrmdrmathrmdsmathrmdt\n\nIn both computations, the differential elements (which only affect amplitude) are neglected.\n\n\n\n\n\n","category":"function"},{"location":"function/regularization.html#","page":"Regularization","title":"Regularization","text":"ConvMap\nLaplacianMap\nDiffZMap\nDiffXMap\nGradDivMap","category":"page"},{"location":"function/regularization.html#KirchMig.ConvMap","page":"Regularization","title":"KirchMig.ConvMap","text":"ConvMap([T,] wavelet, n...) -> W\n\nConstruct a convolution/correlation operator W which will act on an AbstractVector.\n\nParameters\n\nT : Type, optional\n\nType of argument of W. Defaults to Float64.\n\nwavelet\n\nOne-dimensional wavelet.\n\nn...\n\nSequence of dimensions of the data.\n\nUsage\n\nForward map and Adjoint maps\n\nThe forward map W convolves the last dimension of the input with wavelet. The adjoint map W correlates the last dimension of the input with wavelet.\n\n\n\n\n\n","category":"function"},{"location":"function/regularization.html#KirchMig.LaplacianMap","page":"Regularization","title":"KirchMig.LaplacianMap","text":"LaplacianMap([T,] n...) -> Δ\n\nConstruct a discretized Laplacian operator Δ which will act on an AbstractVector.\n\nParameters\n\nT : Type, optional\n\nType of argument of Δ. Defaults to Float64.\n\nn...\n\nSequence of spatial dimensions of Δ.\n\nUsage\n\nForward map and Adjoint maps\n\nThe forward map Δ multiplies a model vector of size nz × nx × ny × ... its second order derivative. It is symmetric.\n\nDescription\n\nThe forward and adjoint maps computes the following operation\n\nΔm = sum_i δ_i m\n\nwhere \n\nδ_l m_ijk = - m_l+1 + 2m_l - m_l-1\n\n\n\n\n\n","category":"function"},{"location":"function/regularization.html#KirchMig.DiffZMap","page":"Regularization","title":"KirchMig.DiffZMap","text":"DiffZMap([T,] n...) -> δz\n\nConstruct a discretized z-derivative operator δz which will act on an AbstractVector.\n\nParameters\n\nT : Type, optional\n\nType of argument of δz. Defaults to Float64.\n\nn...\n\nSequence of spatial dimensions of δz.\n\nUsage\n\nForward map and Adjoint maps\n\nThe forward map δz multiplies a model vector of size nz × nx × ny × ... its first order z-derivative. The adjoint map is minus the forward map.\n\nDescription\n\nThe forward map computes the following operation\n\nδ_z m_ijk = (m_l+1 - m_l-1)2\n\nand the adjoint map computes -δz.\n\n\n\n\n\n","category":"function"},{"location":"function/regularization.html#KirchMig.DiffXMap","page":"Regularization","title":"KirchMig.DiffXMap","text":"DiffXMap([T,] n...) -> δx\n\nConstruct a discretized x-derivative operator δx which will act on an AbstractVector.\n\nParameters\n\nT : Type, optional\n\nType of argument of δx. Defaults to Float64.\n\nn...\n\nSequence of spatial dimensions of δx.\n\nUsage\n\nForward map and Adjoint maps\n\nThe forward map δx multiplies a model vector of size nz × nx × ny × ... its first order x-derivative. The adjoint map is minus the forward map.\n\nDescription\n\nThe forward map computes the following operation\n\nδ_x m_ijk = (m_l+1 - m_l-1)2\n\nand the adjoint map computes -δx.\n\n\n\n\n\n","category":"function"},{"location":"function/regularization.html#KirchMig.GradDivMap","page":"Regularization","title":"KirchMig.GradDivMap","text":"GradDivMap([T,] n...) -> GD\n\nConstruct a discretized gradient operator GD which will act on an AbstractVector.\n\nParameters\n\nT : Type, optional\n\nType of argument of GD. Defaults to Float64.\n\nn...\n\nSequence of spatial dimensions of GD.\n\nUsage\n\nForward map\n\nCalculates the discrete gradient of a nz × nx × ny × ... using first order central differences.\n\nm_ijk = δ_x m_ijk   δ_z m_ijk\n\nAdjoint map\n\nCalculates the discrete negative divergence of a nz × nx × ny × ... using first order central differences.\n\ncdot m_ijk = δ_x m_ijk +   + δ_z m_ijk\n\n\n\n\n\n","category":"function"},{"location":"function/eikonal.html#","page":"Eikonal","title":"Eikonal","text":"eikonal_const_vel","category":"page"},{"location":"function/eikonal.html#KirchMig.eikonal_const_vel","page":"Eikonal","title":"KirchMig.eikonal_const_vel","text":"eikonal_const_vel(src, z, x, [y, ] velocity)\n\nCompute traveltime tables between src locations and subsurface model locations given by z, x, and optionally y. It assumes velocity is constant.\n\nParameters\n\nsrc : (ns, n), AbstractMatrix{<:Real}\n\nThe (z_s, x_s [, x_y]) coordinates for every source. In 2D, n = 2 and in 3D n = 3.\n\nz : (nz,), AbstractVector{<:Real}\n\nModel depth z coordinates.\n\nx : (nx,), AbstractVector{<:Real}\n\nModel horizontal x coordinates.\n\ny : (ny,), AbstractVector{<:Real}, optional\n\nModel horizontal y coordinates.\n\nvelocity : Real\n\nWave speed\n\nReturns\n\ntrav : (nz, nx, [ny, ] ns), AbstractArray{<:Real, M}\n\nTraveltime between each src and locations given by z, x and optionally y:\n\nt(z x y s) = fracsqrt(z-s_z)^2 + (x-s_x)^2 + (y-s_y)^2v\n\n\n\n\n\n","category":"function"},{"location":"function/optimization.html#","page":"Optimization","title":"Optimization","text":"A simple conjugate gradients solver is provided, but using IterativeSolvers.jl is highly recommended.","category":"page"},{"location":"function/optimization.html#","page":"Optimization","title":"Optimization","text":"cg","category":"page"},{"location":"function/optimization.html#KirchMig.cg","page":"Optimization","title":"KirchMig.cg","text":"cg(A, b [, x0];  maxiter=10, tol=1e-3, log=false) -> x [, history_x, history_r]\n\nSolve the system Ax = b of a symmetric, positive definite linear map given by A using the conjugate gradients method.\n\nParameters\n\nA\n\nLinear map, which must have two methods defined: multiplication by AbstractVector and transpose multiplication by AbstractVector.\n\nb : AbstractVector\n\nRHS of equation Ax = b.\n\nx0 : AbstractVector\n\nStarting solution.\n\nmaxiter : Int, optional\n\nMaximum number of iterations. Defaults to 10.\n\ntol : Real, optional\n\nStopping criterion tolerance. Stops if the square root of the ration between the previous and current residuals is smaller than tol. Defaults to 1e-3.\n\nlog : Bool, optional\n\nIf true, returns also model and residuals at each iterations.\n\n\n\n\n\n","category":"function"}]
}
